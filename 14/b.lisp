(defparameter *iter-count* 20)

(defun get-pair-insertion (str)
  (values-list (list (list (schar str 0) (schar str 1)) (schar str 6))))

(defun insert-into-polymer (polymer rules)
  (let* ((pair (list (car polymer) (cadr polymer)))
         (insertion (gethash pair rules))
         (next (when (cddr polymer) (cdr polymer))))
    (setf (cdr polymer) `(,insertion . ,(cdr polymer)))
    (when next (insert-into-polymer next rules))))

(defun get-long-pair-pairs (long-pair)
  (let ((result nil))
    (loop do (let ((pair (list (car long-pair) (cadr long-pair))))
               (push pair result)
               (unless (cddr long-pair)
                 (return result))
               (setq long-pair (cdr long-pair))))))

(defun run-pair (pair rules)
  (let ((long-pair (copy-list pair)))
    (loop for n below *iter-count*
          do (insert-into-polymer long-pair rules))
    long-pair))

(defun tally-counts (p counts)
  (loop for element in p
        do (setf (gethash element counts) (+ (or (gethash element counts) 0) 1))))

(defun add-counts (from to)
  (maphash (lambda (k v)
             (setf (gethash k to) (+ (or (gethash k to) 0) v)))
           from))

(with-open-file (file "sample")
  (let ((rules (make-hash-table :test #'equal))
        (polymer (coerce (read-line file) 'list))
        (long-counts (make-hash-table :test #'equal))
        (long-pair-pairs (make-hash-table :test #'equal))
        (counts (make-hash-table :test #'equal)))
    (read-line file)
    (loop as line = (read-line file nil)
          while line
          do (multiple-value-bind (pair insertion) (get-pair-insertion line)
               (setf (gethash pair rules) insertion)))
    (maphash (lambda (k v)
               (let* ((long-pair (run-pair k rules))
                      (long-count (make-hash-table))
                      (long-pair-pair nil))
                 (tally-counts (subseq long-pair 0 (- (length long-pair) 1)) long-count)
                 (setf (gethash k long-counts) long-count)
                 (setf (gethash k long-pair-pairs) (get-long-pair-pairs long-pair))))
             rules)
    (loop for i below (- (length polymer) 1)
          do (let ((pair (subseq polymer i (+ i 2))))
               (loop for long-pair-pair in (gethash pair long-pair-pairs)
                     do (add-counts (gethash long-pair-pair long-counts) counts))))
    (tally-counts (last polymer) counts)
    (let ((min-count nil) (max-count nil))
      (maphash (lambda (k v)
                 (when (or (not min-count) (< v min-count))
                   (setq min-count v))
                 (when (or (not max-count) (> v max-count))
                   (setq max-count v)))
               counts)
      (format t "~a~%" (- max-count min-count)))))
